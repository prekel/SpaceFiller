// This code was generated by `SqlHydra.Sqlite` -- v0.300.0.0.
namespace SpaceFiller.Db

type Column(reader: System.Data.IDataReader, getOrdinal: string -> int, column) =
        member __.Name = column
        member __.IsNull() = getOrdinal column |> reader.IsDBNull
        override __.ToString() = __.Name

type RequiredColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read(?alias) = alias |> Option.defaultValue __.Name |> getOrdinal |> getter

type OptionalColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getter: int -> 'T, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read(?alias) = 
            match alias |> Option.defaultValue __.Name |> getOrdinal with
            | o when reader.IsDBNull o -> None
            | o -> Some (getter o)

type RequiredBinaryColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getValue: int -> obj, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read(?alias) = alias |> Option.defaultValue __.Name |> getOrdinal |> getValue :?> byte[]

type OptionalBinaryColumn<'T, 'Reader when 'Reader :> System.Data.IDataReader>(reader: 'Reader, getOrdinal, getValue: int -> obj, column) =
        inherit Column(reader, getOrdinal, column)
        member __.Read(?alias) = 
            match alias |> Option.defaultValue __.Name |> getOrdinal with
            | o when reader.IsDBNull o -> None
            | o -> Some (getValue o :?> byte[])
        
module main =
    type fill_record =
        { id: int64
          operation: int
          requested: Option<int>
          precision: Option<int>
          keep: Option<int>
          filled: int
          free: int
          date_time: Option<string> }

    type fill_recordReader(reader: System.Data.IDataReader, getOrdinal) =
        member __.id = RequiredColumn(reader, getOrdinal, reader.GetInt64, "id")
        member __.operation = RequiredColumn(reader, getOrdinal, reader.GetInt32, "operation")
        member __.requested = OptionalColumn(reader, getOrdinal, reader.GetInt32, "requested")
        member __.precision = OptionalColumn(reader, getOrdinal, reader.GetInt32, "precision")
        member __.keep = OptionalColumn(reader, getOrdinal, reader.GetInt32, "keep")
        member __.filled = RequiredColumn(reader, getOrdinal, reader.GetInt32, "filled")
        member __.free = RequiredColumn(reader, getOrdinal, reader.GetInt32, "free")
        member __.date_time = OptionalColumn(reader, getOrdinal, reader.GetString, "date_time")
        member __.Read() =
            { id = __.id.Read()
              operation = __.operation.Read()
              requested = __.requested.Read()
              precision = __.precision.Read()
              keep = __.keep.Read()
              filled = __.filled.Read()
              free = __.free.Read()
              date_time = __.date_time.Read() }

        member __.ReadIfNotNull() =
            if __.id.IsNull() then None else Some(__.Read())

type HydraReader(reader: System.Data.IDataReader) =
    let mutable accFieldCount = 0
    let buildGetOrdinal fieldCount =
        let dictionary = 
            [0..reader.FieldCount-1] 
            |> List.map (fun i -> reader.GetName(i), i)
            |> List.sortBy snd
            |> List.skip accFieldCount
            |> List.take fieldCount
            |> dict
        accFieldCount <- accFieldCount + fieldCount
        fun col -> dictionary.Item col
        
    let lazyfill_record = lazy (main.fill_recordReader (reader, buildGetOrdinal 8))
    member __.fill_record = lazyfill_record.Value
    member private __.AccFieldCount with get () = accFieldCount and set (value) = accFieldCount <- value
    member private __.GetReaderByName(entity: string, isOption: bool) =
        match entity, isOption with
        | "fill_record", false -> __.fill_record.Read >> box
        | "fill_record", true -> __.fill_record.ReadIfNotNull >> box
        | _ -> failwith $"Could not read type '{entity}' because no generated reader exists."

    static member private GetPrimitiveReader(t: System.Type, reader: System.Data.IDataReader, isOpt: bool) =
        let wrap get (ord: int) = 
                if isOpt 
                then (if reader.IsDBNull ord then None else get ord |> Some) |> box 
                else get ord |> box 
        
        if t = typedefof<int16> then Some(wrap reader.GetInt16)
        else if t = typedefof<int> then Some(wrap reader.GetInt32)
        else if t = typedefof<double> then Some(wrap reader.GetDouble)
        else if t = typedefof<System.Single> then Some(wrap reader.GetDouble)
        else if t = typedefof<decimal> then Some(wrap reader.GetDecimal)
        else if t = typedefof<bool> then Some(wrap reader.GetBoolean)
        else if t = typedefof<byte> then Some(wrap reader.GetByte)
        else if t = typedefof<int64> then Some(wrap reader.GetInt64)
        else if t = typedefof<byte []> then Some(wrap reader.GetValue)
        else if t = typedefof<string> then Some(wrap reader.GetString)
        else if t = typedefof<System.DateTime> then Some(wrap reader.GetDateTime)
        else if t = typedefof<System.Guid> then Some(wrap reader.GetGuid)
        else None

    static member Read(reader: System.Data.IDataReader) = 
            let hydra = HydraReader(reader)
            
            let getOrdinalAndIncrement() = 
                let ordinal = hydra.AccFieldCount
                hydra.AccFieldCount <- hydra.AccFieldCount + 1
                ordinal
            
            let buildEntityReadFn (t: System.Type) = 
                let t, isOpt = 
                    if t.IsGenericType && t.GetGenericTypeDefinition() = typedefof<Option<_>> 
                    then t.GenericTypeArguments.[0], true
                    else t, false
            
                match HydraReader.GetPrimitiveReader(t, reader, isOpt) with
                | Some primitiveReader -> 
                    let ord = getOrdinalAndIncrement()
                    fun () -> primitiveReader ord
                | None ->
                    hydra.GetReaderByName(t.Name, isOpt)
            
            // Return a fn that will hydrate 'T (which may be a tuple)
            // This fn will be called once per each record returned by the data reader.
            let t = typeof<'T>
            if FSharp.Reflection.FSharpType.IsTuple(t) then
                let readEntityFns = FSharp.Reflection.FSharpType.GetTupleElements(t) |> Array.map buildEntityReadFn
                fun () ->
                    let entities = readEntityFns |> Array.map (fun read -> read())
                    Microsoft.FSharp.Reflection.FSharpValue.MakeTuple(entities, t) :?> 'T
            else
                let readEntityFn = t |> buildEntityReadFn
                fun () -> 
                    readEntityFn() :?> 'T
        
